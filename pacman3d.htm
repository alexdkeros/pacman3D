<!-- Pacman 3d -->

</script><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Pacman 3D</title>

<!-- external libraries for matrix calculations and maintenance -->
<script type="text/javascript" src="./sandbox_files/glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="./sandbox_files/webgl-utils.js"></script>

<!---------------------------------------------------------------------------------------------------------->
<!------------------SHADERS--------------------------------------------------------------------------------->
<!---------------------------------------------------------------------------------------------------------->

<!-- Code for the vertex shader-->
<script id="shader-vs" type="x-shader/x-vertex">
//attributes for the vertex shader (different for every thread/core that will execute a copy of this)
    attribute vec3 aVertexPosition;
    attribute vec4 aVertexColor;

	//ModelView and Projection Matrices
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

	//Variable to be forwarded to the corresponding thread of the fragment shader
    varying vec4 vColor;

	//main function of the vertex shader
	//this code will be copied to many shader cores/threads and executed with the associated
	//data for every vertex (matrices, color, etc)
    void main(void) {
	
	//Each vertex is multiplied with the ModelView and Projection matrices and created a fragment
	    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
		//Its color is forwarded to the fragment shader
        vColor = aVertexColor;
    }
</script>

<!-- Code for the fragment shader-->
<script id="shader-fs" type="x-shader/x-fragment">
    //necessary code for compatibility
	precision mediump float;

	//Variable coming from the vertex shader
    varying vec4 vColor;

    void main(void) {
	//the fragment gets its color value.
	//in the fragment shader many advanced shading algorithms can be implemented (Phong etc..)
        gl_FragColor = vColor;
    }
</script>


<!---------------------------------------------------------------------------------------------------------->
<!-------------MAIN FUNCTIONALITY--------------------------------------------------------------------------->
<!---------------------------------------------------------------------------------------------------------->
<script type="text/javascript">


	/************************************************
	*************************************************
	****************Initialize WebGL*****************
	*************************************************
	*************************************************/
	// the WebGL context
	var gl;

	function initGL(canvas) {
	    try {
		//get a webgl context
	        gl = canvas.getContext("experimental-webgl");
			//assign a viewport width and height based on the HTML canvas element properties
	        gl.viewportWidth = canvas.width;
	        gl.viewportHeight = canvas.height;
			//any error is handled here
			//all errors are visible in the console (F12 in Google chrome)
	    } catch (e) {
	    }
	    if (!gl) {
	        alert("Could not initialise WebGL, sorry :-(");
	    }
	}


	//Find and compile shaders (vertex + fragment shader)
	function getShader(gl, id) {
	//gets the shader scripts (vertex + fragment)
	    var shaderScript = document.getElementById(id);
	    if (!shaderScript) {
	        return null;
	    }

	    var str = "";
	    var k = shaderScript.firstChild;
	    while (k) {
	        if (k.nodeType == 3) {
	            str += k.textContent;
	        }
	        k = k.nextSibling;
	    }

	    var shader;
		//create shaders
	    if (shaderScript.type == "x-shader/x-fragment") {
	        shader = gl.createShader(gl.FRAGMENT_SHADER);
	    } else if (shaderScript.type == "x-shader/x-vertex") {
	        shader = gl.createShader(gl.VERTEX_SHADER);
	    } else {
	        return null;
	    }

		//ask WebGL to compile shaders
		//we check for errors here too
		//all errors are visible in the console (F12 in Google chrome)
	    gl.shaderSource(shader, str);
	    gl.compileShader(shader);

	    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
	        alert(gl.getShaderInfoLog(shader));
	        return null;
	    }

	    return shader;
	}



	/************************************************
	*************************************************
	***** shaderProgram with specified shaders ******
	*************************************************
	*************************************************/

	var shaderProgram;

	//Creates a program from a vertex + fragment shader pair
	function initShaders() {
	    var fragmentShader = getShader(gl, "shader-fs");
	    var vertexShader = getShader(gl, "shader-vs");

	    shaderProgram = gl.createProgram();
	    gl.attachShader(shaderProgram, vertexShader);
	    gl.attachShader(shaderProgram, fragmentShader);
		//link the compiled binaries
	    gl.linkProgram(shaderProgram);

		//check for errors, again
	    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
	        alert("Could not initialise shaders");
	    }

		//activate current program
		//this sandbox has only on shader pair
		//we can have as many as we wish in more complex applications
	    gl.useProgram(shaderProgram);

		//Update attributes for the vertex shader
		//attributes are accessible only from the vertex shader
		//if we want accessible data from a fragment shader we can use uniform variables,
		//or varyings that will be forwarded from the vertex shader to the fragment shader
		
		//Vertex position data
	    shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
	    gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

		//Vertex color data
	    shaderProgram.vertexColorAttribute = gl.getAttribLocation(shaderProgram, "aVertexColor");
	    gl.enableVertexAttribArray(shaderProgram.vertexColorAttribute);

		//Update uniform variables
		//this variables can be accessed from both the vertex and fragment shader
	    shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
	    shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
	}



	/************************************************
	*************************************************
	********pMatrix and mvMatrix operations**********
	*************************************************
	*************************************************/
	//ModelView and Projection matrices
	//mat4 comes from the external library
	var mvMatrix = mat4.create();
	var mvMatrixStack = [];
	var pMatrix = mat4.create();

	//The matrix stack operation are implemented below to handle local transformations

	//Push Matrix Operation
	function mvPushMatrix() {
	    var copy = mat4.create();
	    mat4.set(mvMatrix, copy);
	    mvMatrixStack.push(copy);
	}

	//Pop Matrix Operation
	function mvPopMatrix() {
	    if (mvMatrixStack.length == 0) {
	        throw "Invalid popMatrix!";
	    }
	    mvMatrix = mvMatrixStack.pop();
	}


	//Sets + Updates matrix uniforms
	function setMatrixUniforms() {
	    gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
	    gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
	}


	//Rotation function helper
	function degToRad(degrees) {
	    return degrees * Math.PI / 180;
	}


	/************************************************
	*************************************************
	********************Buffers**********************
	*************************************************
	*************************************************/

























//end of Javascript
</script>
</head>
<!---------------------------------------------------------------------------------------------------------->
<!---------HMTL for the canvas element---------------------------------------------------------------------->
<!---------------------------------------------------------------------------------------------------------->
<body onload="webGLStart();"> <!-- calls the entry point of our application -->

    <canvas id="Pacman3D" style="border: none;" width="500" height="500"></canvas>

    <br>

</body></html>