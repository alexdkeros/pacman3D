<!-- Pacman 3d -->

</script><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Pacman 3D</title>

<!-- external libraries for matrix calculations and maintenance -->
<script type="text/javascript" src="./sandbox_files/glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="./sandbox_files/webgl-utils.js"></script>

<!---------------------------------------------------------------------------------------------------------->
<!------------------SHADERS--------------------------------------------------------------------------------->
<!---------------------------------------------------------------------------------------------------------->

<!-- Code for the vertex shader-->
<script id="shader-vs" type="x-shader/x-vertex">
//attributes for the vertex shader (different for every thread/core that will execute a copy of this)
    attribute vec3 aVertexPosition;
    attribute vec4 aVertexColor;

	//ModelView and Projection Matrices
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

	//Variable to be forwarded to the corresponding thread of the fragment shader
    varying vec4 vColor;

	//main function of the vertex shader
	//this code will be copied to many shader cores/threads and executed with the associated
	//data for every vertex (matrices, color, etc)
    void main(void) {
	
	//Each vertex is multiplied with the ModelView and Projection matrices and created a fragment
	    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
		//Its color is forwarded to the fragment shader
        vColor = aVertexColor;
    }
</script>

<!-- Code for the fragment shader-->
<script id="shader-fs" type="x-shader/x-fragment">
    //necessary code for compatibility
	precision mediump float;

	//Variable coming from the vertex shader
    varying vec4 vColor;

    void main(void) {
	//the fragment gets its color value.
	//in the fragment shader many advanced shading algorithms can be implemented (Phong etc..)
        gl_FragColor = vColor;
    }
</script>


<!---------------------------------------------------------------------------------------------------------->
<!-------------MAIN FUNCTIONALITY--------------------------------------------------------------------------->
<!---------------------------------------------------------------------------------------------------------->
<script type="text/javascript">


	/************************************************
	*************************************************
	****************Initialize WebGL*****************
	*************************************************
	*************************************************/
	// the WebGL context
	var gl;

	function initGL(canvas) {
		//DBG
		console.log("Initializing canvas");

	    try {
		//get a webgl context
	        gl = canvas.getContext("experimental-webgl");
			//assign a viewport width and height based on the HTML canvas element properties
	        gl.viewportWidth = canvas.width;
	        gl.viewportHeight = canvas.height;
			//any error is handled here
			//all errors are visible in the console (F12 in Google chrome)
	    } catch (e) {
	    }
	    if (!gl) {
	        alert("Could not initialise WebGL, sorry :-(");
	    }

	}


	//Find and compile shaders (vertex + fragment shader)
	function getShader(gl, id) {
		//DBG
		console.log("Getting shaders");

		//gets the shader scripts (vertex + fragment)
	    var shaderScript = document.getElementById(id);
	    if (!shaderScript) {
	        return null;
	    }

	    var str = "";
	    var k = shaderScript.firstChild;
	    while (k) {
	        if (k.nodeType == 3) {
	            str += k.textContent;
	        }
	        k = k.nextSibling;
	    }

	    var shader;
		//create shaders
	    if (shaderScript.type == "x-shader/x-fragment") {
	        shader = gl.createShader(gl.FRAGMENT_SHADER);
	    } else if (shaderScript.type == "x-shader/x-vertex") {
	        shader = gl.createShader(gl.VERTEX_SHADER);
	    } else {
	        return null;
	    }

		//ask WebGL to compile shaders
		//we check for errors here too
		//all errors are visible in the console (F12 in Google chrome)
	    gl.shaderSource(shader, str);
	    gl.compileShader(shader);

	    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
	        alert(gl.getShaderInfoLog(shader));
	        return null;
	    }
	    return shader;
	}



	/************************************************
	*************************************************
	***** shaderProgram with specified shaders ******
	*************************************************
	*************************************************/

	var shaderProgram;

	//Creates a program from a vertex + fragment shader pair
	function initShaders() {
		//DBG
		console.log("Initializing shaders");

	    var fragmentShader = getShader(gl, "shader-fs");
	    var vertexShader = getShader(gl, "shader-vs");

	    shaderProgram = gl.createProgram();
	    gl.attachShader(shaderProgram, vertexShader);
	    gl.attachShader(shaderProgram, fragmentShader);
		//link the compiled binaries
	    gl.linkProgram(shaderProgram);

		//check for errors, again
	    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
	        alert("Could not initialise shaders");
	    }

		//activate current program
		//this sandbox has only on shader pair
		//we can have as many as we wish in more complex applications
	    gl.useProgram(shaderProgram);

		//Update attributes for the vertex shader
		//attributes are accessible only from the vertex shader
		//if we want accessible data from a fragment shader we can use uniform variables,
		//or varyings that will be forwarded from the vertex shader to the fragment shader
		
		//Vertex position data
	    shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
	    gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

		//Vertex color data
	    shaderProgram.vertexColorAttribute = gl.getAttribLocation(shaderProgram, "aVertexColor");
	    gl.enableVertexAttribArray(shaderProgram.vertexColorAttribute);

		//Update uniform variables
		//this variables can be accessed from both the vertex and fragment shader
	    shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
	    shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");

	}



	/************************************************
	*************************************************
	********pMatrix and mvMatrix operations**********
	*************************************************
	*************************************************/
	//ModelView and Projection matrices
	//mat4 comes from the external library
	var mvMatrix = mat4.create();
	var mvMatrixStack = [];
	var pMatrix = mat4.create();

	//The matrix stack operation are implemented below to handle local transformations

	//Push Matrix Operation
	function mvPushMatrix() {
	    var copy = mat4.create();
	    mat4.set(mvMatrix, copy);
	    mvMatrixStack.push(copy);
	}

	//Pop Matrix Operation
	function mvPopMatrix() {
	    if (mvMatrixStack.length == 0) {
	        throw "Invalid popMatrix!";
	    }
	    mvMatrix = mvMatrixStack.pop();
	}


	//Sets + Updates matrix uniforms
	function setMatrixUniforms() {
	    gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
	    gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
	}


	//Rotation function helper
	function degToRad(degrees) {
	    return degrees * Math.PI / 180;
	}




























/************************************************
*************************************************
********************Objects**********************
*************************************************
*************************************************/
/**
colored object
@constructor
*/
function ColoredObject(){
	/*object properties*/
	this.vertexPositionBuffer;
	this.vertexColorBuffer;
	this.vertexIndexBuffer;
	/**
	forms object
	@param {float array, int, int} vertices Contains vertices positions and vertices.itemSize, vertices.numItems attributes
	@param {float array, int, int} colors Contains color definitions and colors.itemSizem, colors.numItems attributes
	@param {int array, int, int} indices Contains vertex indices and indices.itemSize, indices.numItems attributes
	*/
	this.formObject=function(vertices,colors,indices){
		//DBG
		console.log("Forming object");

		//vertices
		this.vertexPositionBuffer=gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER,this.vertexPositionBuffer);
		gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(vertices),gl.STATIC_DRAW);
		this.vertexPositionBuffer.itemSize=vertices.itemSize;
		this.vertexPositionBuffer.numItems=vertices.numItems;

		//colors
		this.vertexColorBuffer=gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER,this.vertexColorBuffer);
		gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(colors),gl.STATIC_DRAW);
		this.vertexColorBuffer.itemSize=colors.itemSize;
		this.vertexColorBuffer.numItems=colors.numItems;
		
		//indices
		this.vertexIndexBuffer=gl.createBuffer();
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,this.vertexIndexBuffer);
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,new Uint16Array(indices),gl.STATIC_DRAW);
		this.vertexIndexBuffer.itemSize=indices.itemSize;
		this.vertexIndexBuffer.numItems=indices.numItems;
	}

	/**
	draw object
	@private
	@param {gl.MODE} drawingMode, example is gl.TRIANGLES
	*/
	this.drawObj_=function(drawingMode){
		//DBG
		console.log("Sending to shaderProgram, drawElement");

		//vertices
		gl.bindBuffer(gl.ARRAY_BUFFER,this.vertexPositionBuffer);
		gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute,this.vertexPositionBuffer.itemSize,gl.FLOAT, false, 0, 0);
		//colors
		gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexColorBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, this.vertexColorBuffer.itemSize, gl.FLOAT, false, 0, 0);
        //indices
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.vertexIndexBuffer);
        //update uniforms
        setMatrixUniforms();
        //Triangles mode
        gl.drawElements(drawingMode, this.vertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
    }

    /**
    draw object with specified translation
	@param {float array} translation Translation array [x , y, z]
	@param {float, float array} rotation Rotation with rotation.angle and rotation.rotAxis attributes
	*/
	this.drawObj=function(translation, rotation){
		//DBG
		console.log("Drawing Object to specified location");
		console.log(translation);
		console.log(rotation);

		mvPushMatrix();
		mat4.translate(mvMatrix, translation);
		mat4.rotate(mvMatrix, degToRad(rotation.angle), rotation.rotAxis);
		this.drawObj_(gl.TRIANGLES);
		mvPopMatrix();
	}
}



































































	/************************************************
	*************************************************
	********************Buffers**********************
	*************************************************
	*************************************************/


	//Initialize VBOs, IBOs and color
    function initBuffers(cube) {
        vertices = [
            // Front face
            -1.0, -1.0,  1.0,
             1.0, -1.0,  1.0,
             1.0,  1.0,  1.0,
            -1.0,  1.0,  1.0,

            // Back face
            -1.0, -1.0, -1.0,
            -1.0,  1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0, -1.0, -1.0,

            // Top face
            -1.0,  1.0, -1.0,
            -1.0,  1.0,  1.0,
             1.0,  1.0,  1.0,
             1.0,  1.0, -1.0,

            // Bottom face
            -1.0, -1.0, -1.0,
             1.0, -1.0, -1.0,
             1.0, -1.0,  1.0,
            -1.0, -1.0,  1.0,

            // Right face
             1.0, -1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0,  1.0,  1.0,
             1.0, -1.0,  1.0,

            // Left face
            -1.0, -1.0, -1.0,
            -1.0, -1.0,  1.0,
            -1.0,  1.0,  1.0,
            -1.0,  1.0, -1.0
        ];
        vertices.itemSize = 3;
		//we have 24 vertices
        vertices.numItems = 24;

        //colors
		colors = [
            [1.0, 0.0, 0.0, 1.0], // Front face
            [1.0, 1.0, 0.0, 1.0], // Back face
            [0.0, 1.0, 0.0, 1.0], // Top face
            [1.0, 0.5, 0.5, 1.0], // Bottom face
            [1.0, 0.0, 1.0, 1.0], // Right face
            [0.0, 0.0, 1.0, 1.0]  // Left face
        ];
        var unpackedColors = [];
        for (var i in colors) {
            var color = colors[i];
			//assign colors for each vertex of each face based on the packed representation above
            for (var j=0; j < 4; j++) {
                unpackedColors = unpackedColors.concat(color);
            }
        }
        unpackedColors.itemSize = 4;
		//24 color values (we have 24 vertices to color...)
        unpackedColors.numItems = 24;

		//Index Buffer Object
		var cubeVertexIndices = [
		//this numbers are positions in the VBO array above
            0, 1, 2,      0, 2, 3,    // Front face
            4, 5, 6,      4, 6, 7,    // Back face
            8, 9, 10,     8, 10, 11,  // Top face
            12, 13, 14,   12, 14, 15, // Bottom face
            16, 17, 18,   16, 18, 19, // Right face
            20, 21, 22,   20, 22, 23  // Left face
        ];
		cubeVertexIndices.itemSize = 1;
		//we have 36 indices (6 faces, every face has 2 triangles, each triangle 3 vertices: 2x3x6=36)
        cubeVertexIndices.numItems = 36;
    
    	cube.formObject(vertices, unpackedColors, cubeVertexIndices);
    }






	//For every frame this function draws the complete scene from the beginning
    function drawScene(cube) {
	//the viewport gets the canvas values (that were assigned to the gl context variable)
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
		//the frame and depth buffers get cleaned (the depth buffer is used for sorting fragments)
		//without the depth buffer WebGL does not know which fragment is visible for a given pixel
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

		//the projection matrix (pMatrix) is set
		//45 degrees Field-Of-View
		//aspect ratio gl.viewportWidth / gl.viewportHeight
		//near plane: 0.1 , far plane: 100
        mat4.perspective(45, (gl.viewportWidth / gl.viewportHeight), 0.1, 100.0, pMatrix);

		//the modelview Matrix is initialized with the Identity Matrix
        mat4.identity(mvMatrix);
		
		//the ModelView matrix gets a global transformation ("camera" retracts 8 units)
		//otherwise the "camera" will be inside the rotating cube
		//z-axis points out of the screen. we translate -8 which is the inverse transform
		//in essence we move the world -8 units to have the camera 8 units forward.
		//REMEMBER there is no actual camera in WebGL
		mat4.translate(mvMatrix, [0.0, 0.0, -10.0]);
		mat4.rotate(mvMatrix, degToRad(0),[1.0, 0.0, 0.0]);

		var trans=[0.0,0.0,0.0];
		var rot={angle:45.0,rotAxis:[1.0, 1.0, 0.0]};
		cube.drawObj(trans,rot);
		
	}



	//Entry point of the WebGL context
	function webGLStart() {
        var canvas = document.getElementById("Pacman3D");
        
		//Functions for initialization
		//Check above
		initGL(canvas);
		var cube=new ColoredObject();
        initShaders(cube)
        initBuffers(cube);

		//Background Color: Color assigned for all pixels with no corresponding fragments
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
		
		//Enable z-buffer for depth sorting
        gl.enable(gl.DEPTH_TEST);

		//the first tick of our application
        drawScene(cube);
    }















//end of Javascript
</script>
</head>
<!---------------------------------------------------------------------------------------------------------->
<!---------HMTL for the canvas element---------------------------------------------------------------------->
<!---------------------------------------------------------------------------------------------------------->
<body onload="webGLStart();"> <!-- calls the entry point of our application -->

    <canvas id="Pacman3D" style="border: none;" width="500" height="500"></canvas>

    <br>

</body></html>